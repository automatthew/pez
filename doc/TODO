This is a sort of unordered roadmap for Pez.

* Re-work the I/O, add most of the C system calls.  There's a branch for this.

* Fix the bug with undefined words being referenced in definitions.  (A
  segfault, oh my!)

* Regexes.  They'll be here shortly.

* Change error behavior from "keep going starting at the next word" to
  "discard the rest of the input stream, return to toplevel".  This
  seems to be a better plan for both embedded code and for running as a
  standalone script.  Especially if an error is encountered in a
  definition, the current behavior is to keep going, but in interpret
  mode rather than compile mode, so the word that was getting defined
  *starts*running* in the middle!  Seems like a bad plan.

* Autotools tweaks.  Specifically, I'm incompetent with that build
  system, and a few things need to happen:
  	* pez.h really badly needs to be installed.
	* The standard collection of FFI libraries (most of which are
	  yet to be written, except for a minimal SDL proof-of-concept)
	  need to be built and installed in /usr/lib/pez/ (or wherever
	  autotools and the runner of ./configure decide is
	  appropriate) and the path to this library defined where Pez
	  can see it, so that it can install and load libraries.
	* The various compile-time options need to be settable by
	  configure rather than CFLAGS.

* Enable multiple instances within a single process.  This is both nice to have
  and necessary for the concurrency model I want to implement (a stack-based
  language works best as shared-nothing, I think), or to instantiate sandboxed
  interpreters from inside Pez programs.  It's going to be kind of tedious,
  though, as it will require moving all of the static variables into a struct
  (representing the interpreter; each with its own stack, return stack, input
  stream, heap, etc.), then changing all of the primitives to take a pointer to
  the interpreter as an argument.  So I'm sort of lazily putting it off for now.

* Serialization of the dictionary/code/etc.
	* I expect text to be easier than binary images.
	* Also, do both if possible.

* Add examples for the FFI, and write a couple of libraries.

* Set up something like $LIBDIR/pez, to make it a little more easy to distribute
  a standard library (both FFI .so files and regular .pez files) with Pez and
  load files from it.

* Maybe get rid of the case-insensitivity and turn everything lower-case;
  depends on how much of a pain that turns out to be.

* Misc cleanup
	* Make my own idioms conform a little more to the Atlast codebase, where
	  it makes sense.
	* Fix up some of Atlast's quirks, where it makes sense.  (e.g., change
	  'Push = x' to 'Push(x)'.)

* Investigate a few key optimizations, as I'm planning on using Pez as an
  intermediate language for Roboto.

* Along those lines, there are a few Roboto features that may be pushed down to
  Pez, like garbage collection, although this will only happen where it does not
  interfere with Pez as a standalone language or embedded scripting language.
