This is a sort of unordered roadmap for Pez.

* Support running as script (#!/usr/bin/env pez)
  I think it is probably better to change the comment character (more
  like a word that does m4's dnl than a "comment character") from \ to
  #, than to make some sort of exception for #! if it starts a file.

* Change error behavior from "keep going starting at the next word" to
  "discard the rest of the input stream, return to toplevel".  This
  seems to be a better plan for both embedded code and for running as a
  standalone script.  Especially if an error is encountered in a
  definition, the current behavior is to keep going, but in interpret
  mode rather than compile mode, so the word that was getting defined
  *starts*running* in the middle!  Seems like a bad plan.

* Autotools tweaks.  Specifically, I'm incompetent with that build
  system, and a few things need to happen:
  	* pez.h really badly needs to be installed.
	* The standard collection of FFI libraries (most of which are
	  yet to be written, except for a minimal SDL proof-of-concept)
	  need to be built and installed in /usr/lib/pez/ (or wherever
	  autotools and the runner of ./configure decide is
	  appropriate) and the path to this library defined where Pez
	  can see it, so that it can install and load libraries.
	* The various compile-time options need to be settable by
	  configure rather than CFLAGS.

* The NOMEMCHECK macro enables the following:
	1. Walkback
	2. Tracing
	3. 'Compiling' check
	4. Zero division errors
	5. Pointers must only point within the heap.
	6. Heap bounds checking
	7. Return stack bounds checking
	8. Stack bounds checking
	9. Array bounds checking
	A. Array allocation checking
  Split it into "RUNTIME_DIAGNOSTICS" (1, 2), "BOUNDS_CHECK" (6-9),
  "RESTRICTED_POINTERS" (5.  It's still desirable to have the feature for
  embedding, less so for standalone programs), "MATH_CHECK" (4).  (A) will
  always be enabled; I can't think of a use for it besides using it as a clever
  way to free heap space.  (There are plans for allowing more direct
  manipulation of some of these anyway, when multiple instances of the
  interpreter are possible.)

* Enable multiple instances within a single process.  This is both nice to have
  and necessary for the concurrency model I want to implement (a stack-based
  language works best as shared-nothing, I think), or to instantiate sandboxed
  interpreters from inside Pez programs.  It's going to be kind of tedious,
  though, as it will require moving all of the static variables into a struct
  (representing the interpreter; each with its own stack, return stack, input
  stream, heap, etc.), then changing all of the primitives to take a pointer to
  the interpreter as an argument.  So I'm sort of lazily putting it off for now.

* Serialization of the dictionary/code/etc.
	* I expect text to be easier than binary images.
	* Also, do both if possible.

* Add examples for the FFI, and write a couple of libraries.

* A make install task, and a Pkgfile for CRUX at least.

* Set up something like $LIBDIR/pez, to make it a little more easy to distribute
  a standard library (both FFI .so files and regular .pez files) with Pez and
  load files from it.

* Maybe get rid of the case-insensitivity and turn everything lower-case;
  depends on how much of a pain that turns out to be.

* Misc cleanup
	* Make my own idioms conform a little more to the Atlast codebase, where
	  it makes sense.
	* Fix up some of Atlast's quirks, where it makes sense.  (e.g., change
	  'Push = x' to 'Push(x)'.)

* Investigate a few key optimizations, as I'm planning on using Pez as an
  intermediate language for Roboto.

* Along those lines, there are a few Roboto features that may be pushed down to
  Pez, like garbage collection, although this will only happen where it does not
  interfere with Pez as a standalone language or embedded scripting language.
