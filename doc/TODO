This is a sort of unordered roadmap for Pez.

* NOMEMCHECK enables the following:
	1. Walkback
	2. Tracing
	3. 'Compiling' check
	4. Zero division errors
	5. Pointers must only point within the heap.
	6. Heap bounds checking
	7. Return stack bounds checking
	8. Stack bounds checking
	9. Array bounds checking
	A. Array allocation checking
  Split it into "RUNTIME_DIAGNOSTICS" (1, 2), "BOUNDS_CHECK" (6-9),
  "RESTRICTED_POINTERS" (5.  It's still desirable to have the feature for
  embedding, less so for standalone programs), "MATH_CHECK" (4).  (A) will
  always be enabled; I can't think of a use for it besides using it as a clever
  way to free heap space.  (There are plans for allowing more direct
  manipulation of some of these anyway, when multiple instances of the
  interpreter are possible.)

* Enable multiple instances of Pez within a single process.

* Serialization of the dictionary/code/etc.
	* I expect text to be easier than binary images.
	* Also, do both if possible.

* Add examples for the FFI, and write a couple of libraries.

* A make install task, and a Pkgfile for CRUX at least.

* Set up something like $LIBDIR/pez, to make it a little more easy to distribute
  a standard library along with Pez and load files from it.

* Maybe get rid of the case-insensitivity and turn everything lower-case;
  depends on how much of a pain that turns out to be.

* Misc cleanup
	* Make my own idioms conform a little more to the Atlast codebase, where
	  it makes sense.
	* Fix up some of Atlast's quirks, where it makes sense.  (e.g., change
	  'Push = x' to 'Push(x)'.)

* Investigate a few key optimizations, as I'm planning on using Pez as an
  intermediate language for Roboto.

* Along those lines, there are a few Roboto features that may be pushed down to
  Pez, like garbage collection and tail-call optimization, although this will
  only happen where it does not interfere with Pez as a standalone language or
  embedded scripting language.
