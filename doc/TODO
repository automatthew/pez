This is a sort of unordered roadmap for Pez.

* Support running as script (#!/usr/bin/env pez)

* NOMEMCHECK enables the following:
	1. Walkback
	2. Tracing
	3. 'Compiling' check
	4. Zero division errors
	5. Pointers must only point within the heap.
	6. Heap bounds checking
	7. Return stack bounds checking
	8. Stack bounds checking
	9. Array bounds checking
	A. Array allocation checking
  Split it into "RUNTIME_DIAGNOSTICS" (1, 2), "BOUNDS_CHECK" (6-9),
  "RESTRICTED_POINTERS" (5.  It's still desirable to have the feature for
  embedding, less so for standalone programs), "MATH_CHECK" (4).  (A) will
  always be enabled; I can't think of a use for it besides using it as a clever
  way to free heap space.  (There are plans for allowing more direct
  manipulation of some of these anyway, when multiple instances of the
  interpreter are possible.)

* Enable multiple instances within a single process.  This is both nice to have
  and necessary for the concurrency model I want to implement (a stack-based
  language works best as shared-nothing, I think), or to instantiate sandboxed
  interpreters from inside Pez programs.  It's going to be kind of tedious,
  though, as it will require moving all of the static variables into a struct
  (representing the interpreter; each with its own stack, return stack, input
  stream, heap, etc.), then changing all of the primitives to take a pointer to
  the interpreter as an argument.  So I'm sort of lazily putting it off for now.

* NOMEMCHECK enables the following:
	1. Walkback
	2. Tracing
	3. 'Compiling' check
	4. Zero division errors
	5. Pointers must only point within the heap.
	6. Heap bounds checking
	7. Return stack bounds checking
	8. Stack bounds checking
	9. Array bounds checking
	A. Array allocation checking
  Split it into "RUNTIME_DIAGNOSTICS" (1, 2), "BOUNDS_CHECK" (6-9),
  "RESTRICTED_POINTERS" (5.  It's still desirable to have the feature for
  embedding, less so for standalone programs), "MATH_CHECK" (4).  (A) will
  always be enabled; I can't think of a use for it besides using it as a clever
  way to free heap space.  (There are plans for allowing more direct
  manipulation of some of these anyway, when multiple instances of the
  interpreter are possible.)

* Enable multiple instances of Pez within a single process.

* Serialization of the dictionary/code/etc.
	* I expect text to be easier than binary images.
	* Also, do both if possible.

* Add examples for the FFI, and write a couple of libraries.

* A make install task, and a Pkgfile for CRUX at least.

* Set up something like $LIBDIR/pez, to make it a little more easy to distribute
  a standard library (both FFI .so files and regular .pez files) with Pez and
  load files from it.

* Maybe get rid of the case-insensitivity and turn everything lower-case;
  depends on how much of a pain that turns out to be.

* Misc cleanup
	* Make my own idioms conform a little more to the Atlast codebase, where
	  it makes sense.
	* Fix up some of Atlast's quirks, where it makes sense.  (e.g., change
	  'Push = x' to 'Push(x)'.)

* Investigate a few key optimizations, as I'm planning on using Pez as an
  intermediate language for Roboto.

* Along those lines, there are a few Roboto features that may be pushed down to
  Pez, like garbage collection and tail-call optimization, although this will
  only happen where it does not interfere with Pez as a standalone language or
  embedded scripting language.
